Neatu Darius-Florentin
325CA


	Am ales sa implementez problemele 1 si 3.

	Problema 1 - joc
	Am ales o abordare de tip greedy care se bazeaza pe mai multe observatii:
	- problema are solutia daca si numai daca exista maxim un caracter
care apare de un numar impar de ori in sir (in acest scop am creat un
vector de frecventa). Daca nu am astfel de caractere atunci sirul
se poate face un palindrom de lungime para. Daca am un astfel de caracter
sirul va avea acest caracter in mijloc.
    - restrictiile asupra operatiilor prezentate in enunt impun o abordare
dinspre exterior spre interior (abordarea opusa ar putea strica modificarile
de la pasul anterior).
    - aleg doi pointeri i si j, care vor parcurge sirul de la stanga la dreapta
(++i), respectiv de la dreapta la stanga (--j). Daca sirul ar fi palindrom 
atunci s[i] == s[j], in caz contrar este nevoie sa schimb pe s[i] sau s[j].
			* daca schimb pe s[i] ar trebui sa caut cel mai apropiat
caracter de la dreapta lui i egal cu s[j]
		    * daca schimb pe s[j] ar trebui sa caut cel mai apropiat
caracter de la stanga lui j egal cu s[i]
		Aleg solutia care genereaza un numar minim de mutari.
	Caz particular: Daca s[i] != s[j], verific daca nu cumva unul dintre cele
doua caractere este cel care trebuie sa fie la mijloc. In caz afirmativ
imping acest caracter catre mijloc, apoi compar din nou pe s[i] cu s[j].
	Pe parcurs decrementez numarul de aparitii al caracterelor deja procesate
(plasate "bine"), astfel incat daca intalnesc un caracter cu frecventa 1
acesta reprezinta ultima aparitie a caracterului care aparea de numar
impar de ori, prin urmare stiu ca pe acesta trebuie sa il imping catre mijloc.
	Am creat o functie solve(char *s) care rezolva problema pentru un singur
sir dat ca input.
	Complexitate temporala: O(N^2) (in total O(T * N^2) )
	Complexitate spatiala: O(N)
		* N = numarul de caractere dintr-un sir
		* T = numarul de teste (siruri din fisier)

	Problema 3 - cablaj
	Desi aparent problema parea ca admite o solutie de tip greedy, aceasta
este o problema clasica de programare dinamica. 
	Cum am descoperit acest lucru?
		* Argument1: solutia de tip greedy pica din testele create de mine
si mi-am dat ca nu lua toate cazurile in considerare.
        * Argument2: exista o asemanare foarte mare intre aceasta problema si
problema parantezarii optime de matrici (infoarena) sau problema parantezarii 
unei expresii booleene (laboratorul 3). Deoarece aceasta problema urmeaza 
acelasi pattern, rationamentul prin care se va rezolva va fi asemanator cu
cel de la laborator.
	Intrucat problema cere minimizarea unei solutii am cautat o recurenta
care sa gaseasca un minim. Se poate observa foarte simplu ca o recurenta liniara
este imposibil de scos, intrucat in aceasta problema este necesar sa lucram 
cu perechi (i,j) (nu putem genera toate perechile in timp liniar).
    Prin urmare construiesc o recurenta bidimensionala:
    D[i][j] = costul minim pentru a rezolva problema considerand doar
              subsirul de pini de la i la j (prin cost am notat lungimea
              minima totala a traseelor folosite respectand restrictiile din
              enunt)
    Intrucat si lungimea pe verticala este un element esential care poate 
determina solutia pentru un alt interval, notez lungimea maxima pe verticala
ca fiind inaltime, construind matricea:
	H[i][j] = inaltimea maxima a unui traseu folosit in constructia solutiei
	          optime pentru intervalul i,j
	Obs. Elementele din perechea (D[i][j], H[i][j]) sunt actualizate simultan!

	In continuare voi explica cum am gasit recurentele pentru a rezolva un 
interval [i, j] pentru care am doua variante:
	1. Pinii i si j sunt diferiti, prin urmare pot uni direct pinul i cu pinul j
cu un traseu a carui inaltime este conditionata de inaltimea maxima aparuta pe
intervalul [i+1, j-1].

	*  *  *  *  *  *  *  *  *  *  *  *
	*  *  *  *  *  *  *  *  *  *  *  *
	*  *                          *  * 
	*  *                          *  * 
	i i+1 .....................  j-1 j
	Din figura se observa ca inaltimea minima pentru i,j trebuie sa fie cu 1 mai mare
decat inaltimea maxima folosita pentru i+1,j-1 cand am construit recursiv solutia optima. Se obtine:
	height = 1 + H[i + 1][j - 1];
	cost = j - i + 2 * height + D[i + 1][j - 1];
	Verific daca perechea (cost, height) poate actualiza (D[i][j], H[i][j]).

	2. Aleg sa nu conectez pinii i cu j. In acest caz voi alege un pin k intermediar
si voi crea doua conexiuni FICTIVE ca in figura.
	*  *  *  *  *  *  *  *  *  *  *  
	*              *  *           *  
	*              *  *           *  
	*              *  *           *  
	i ............ k k+1 .......  j 
	In figura se observa solutia pentru i,j este data de solutiile optime pentru cele
doua subseturi. OBSERVATIE: in figura anterioara un traseu inseamna doar ca am ales sa
rezolv separat un subset ale carui capete nu sunt neaparat conectate.
	Pentru un k fixat, valid (trebuie sa am un numar par de pini in ambele subseturi)
obtin:
	cost = D[i][k] + D[k + 1][j];
	height = max(H[i][k], H[k + 1][j]);
	Prin iterarea dupa toate valorile posibile ale lui k gasesc solutii care pot
minimiza costul pentru intervalul i,j.
	Implementarea acestor recurente este facuta in functia makeDP. Pentru o 
implementare eficienta se observa ca vom folosi doar triunghiul superior din fiecare matrice. Aceste elemente le vom calcula diagonala cu diagonala, rezultand o complexitate de O(N^3). Valorile care reprezinta lipsa solutiei pe un interval
le initializez cu infinit.


	Pentru reconstituirea cuplajelor am creat functia rebuild care porneste cu interval
[i,j] (initial [1, n]) si pe baza informatiilor din D si H decide daca prin care dintre cazurile de mai sus s-a obtinut solutia optima pentru intervalul [i,j], afisand perechea (i,j) daca i si j au fost cuplati, apoi reconstituie recursiv solutia pentru intervalele care au generat aceasta solutie [i+1, j-1] / [i,k][k+1,j]. Daca in calcularea dinamicii se porneste cu intervale de lungime 1, 2, 3,.., la reconstituire
se pleaca cu intervalul de lungime n, spargandu-se in intervale mai mici pana se ajunge
la intervale elementare.
	Complexitate temporala: O(N^3)
	Complexitate spatiala: O(N^2)
		* N = numarul de pini

	Testele permit trecerea si a unui solutii in O(N^4)! Mentionez ca se poate gasi 
recurenta de forma:
	D[i][j][h] = solutia optima care se poate obtine pentru subsetul de pini [i,j]
	             urcand pana la o inaltime maxima egala cu h
	Se observa ca aceasta recurenta contine si informatie iredundanta in a 3-a 
dimensiune. S-a demonstrat mai sus ca pentru un interval [i,j] este relevanta
doar inaltimea maxima a subseturilor pe care le contine acesta.