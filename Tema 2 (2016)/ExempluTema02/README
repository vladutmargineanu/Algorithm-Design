Neatu Darius-Florentin
325CA

				README - Tema 2

	Problema 1 - KimLandia
    Precizari initiale:
    * N = numar de noduri, M = numar de muchii
    * am ales sa folosesc o clasa pentru a nu declara variabile globale
    * rularea algoritmului pentru tema incepe in metoda run
    * in continuare voi folosi abrevierea APM pentru Arbore Partial de cost Minim
(nu imi place AMA :D).
    Pentru a calcula APM-ul am folosit algoritmul lui Kruskal, care are complexitate
O(MlogM + Mlog*N), intrucat sortez muchiile, dupa care parcurg toate muchiile
si ma folosesc de structura de date de paduri de multimi disjuncte pentru
a afla in ce multime (componenta conexa)se afla un nod/pentru a reuni doua
multimi (componente conexe). Aceste doua operatii se pot realiza in complexitate
log*N (logaritm iterat, care pentru N-ul problemei este mai mic sau egal cu 5).
Intrucat algoritmul Kruskal a fost studiat in laborator, nu il voi detalia.
    APM-ul il salvez in doua forme: ca vector de muchii (necesar algoritmului
Kruskal) si ca un graf cu liste de adiacenta (necesar pentru partea a doua a
problemei - ex. parcurgere in adancime).
    Pentru partea a doua, pornesc de la observatiile urmatoare: daca am APM-ul
creat, iar pentru un query mi se impune o anumita muchia al carei capete sunt
x si y, atunci prin adaugarea ei se pot intampla urmatoarele:
    - daca muchia este deja in APM, costul solutiei de rezerva este chiar
costul APM-ului; nu trebuie sa fac nimic
    - daca muchia nu este in APM, atunci prin adaugarea ei se va crea un
ciclu. Trebuie sa sparg acest ciclu (un arbore nu trebuie sa aiba cicluri),
prin urmare trebuie sa elimin o muchie din ciclu. Intrucat doresc ca solutia
de rezerva sa aiba cost minim, voi elimina muchia de cost maxim.
Costul solutiei de rezerva difera prin costul APM-ului doar prin costul
muchiei adaugate si a celei scoase:
cost_rezerva = cost_apm + cost_muchie_adaugata - cost_muchie_scoasa
    Prin urmare acesta este algoritmul pentru procesarea unui query.

    PROBLEMA NOUA: Cum gasesc eficient muchia de cost maxim de pe lantul
de la x la y? (x,y noduri in arbore).
    Obs. Complexitatea unui query va fi complexitatea in care pot sa raspund
la aceasta intrebare.
    Fac urmatoarele observatii:
    - pana acum am un arbore fara radacina, nu ofera prea multe variante.
Daca aleg insa o radacina la intamplare atunci observ ca noduri ca am
frant in doua lantul de la x la y. Cele doua bucati se intalnesc intr-un
nod, anume in Cel Mai Recent Stramos Comon (Lowest Common Ancestor alias LCA).
    - muchia de cost maxim de la x la y, este muchia cu cel mai mare cost
dintre muchiile de cost maxim de pe lanturile x-..-lca(x,y) si y-..-lca(y).
De ce ma ajuta aceasta abordare? Este mult mai simplu sa urci intr-un arbore
din parinte in parinte decat sa faci altfel de tranversari.
    - am obtinut o problema particulara: Cum gasesc eficient muchia de cost maxim
de pe lantul de la x la y, y stramos al lui x? (x,y noduri in arbore). Aceasta se
poate rezolva eficient cu o abordare asemanatoare cu problema clasica stramosi.
    In esenta, este necesar sa cunosc intr-un mod eficient care este cel de-al
p-lea stramos al nodului i. Pentru a obtine o complexitate buna, ma folosesc
de reprezentarea binara a lui p (care are log2(p) biti). O sa demonstrez mai
jos ca pot afla acest stramos in complexitate O(logN). Voi demonstra ca
daca fac o preprocesare, pot afla si LCA pentru doua noduri in complexitate
O(1).
    Concluzie: Obtin O(logN) pentru un query.

    Structuri de date/algoritmi standard folositi
    * Paduri de multimi disjuncte (disjoint set) + Kruskal
        Se asociaza ideea de multime cu ideea de componenta conexa. Daca am mai
multe multimi, defapt am mai multe componenteconexa.
            Doresc sa pot face rapid urmatoarele operatii:
        - in ce multime se afla x?
        - reuneste multimile din care fac parte x si y
            Pentru prima intrebare raspunsul indicele multimii va fi defapt radacina arborelui
        din care face parte x. A doua operatie se realizeaza gasind cele doua radacini ale
        arborilor din care fac parte x si y. O radacina devine tatal celeilalte.
            Initial se porneste cu N multimi disjuncte (N nodui izolate, inca nu am APM).
            Cand procesez o anumita muchie, daca capetele ei se afla in multimi diferite,
        atunci aceasta muchie este o muchie intre doua componente conexa. O adaug si astfel
        reunesc cele doua componenta intr-una singura. Dupa N-1 de astfel de operatii reusite,
        au disparut N-1 componente conexe, deci am reusit sa formez un graf conex. Intrucat
        am adaugat fix N-1 muchii, este un arbore. Costul este minim deoarece incerc muchiile
        crescator dupa cost.

    * Parcurgere Euler
            Este o parcurge in adancime care genereaza lista de noduri prin care trece. Particularitatea
        provine din faptul ca un nod se adauga la parcurgere (lista) cand este descoperit si dupa ce
        s-a vizitat fiecare copil al lui. Complexitate O(N+M), O(N) daca se face pe arbore.

    * LCA (Lowest Common Ancestor)
            Pornesc de la urmatoare teorema: "Cel mai apropiat stramos comun a 2 noduri este nodul
        de nivel minim dintre primele aparitii ale nodurilor din query din reprezentarea Euler
        a arborelui."
            Prin urmare realizez parcugerea Euler, retin prima aparitie a fiecarui nod in parcurgere,
        precum si nivelul fiecarui nod.
            Problema se reduce la a gasi elementul minim dintre doua pozitii din vector (nodul de nivel
        minim). Pentru a putea calcula minimul pe interval (orice interval) folosesc tehnica RMQ.

    * RMQ (Range minimum query)
            Pentru a afla minimimul (maximul) pe un interval de indici de forma  [i,j] dintr-un vector,
        ma folosesc de ideea de la cautare binara pe biti, adica de reprezentarea binara a lungimi
        intevalului.
            Ideea este ca daca cunosc raspunsul pentru orice interval de forma [i, i + 2^k) (lungime putere
        a lui 2), atunci pot imparti un interval mare in intervale mai mici si raspunsul e minimul dintre ele.
            Precalculez raspunsul pentru intervalele de lungime 2^0, apoi 2^1, apoi 2^2 etc.
            Dinamica este urmatoarea:
            RMQ[ k ][ i ] = elementul minim dintre pozitiile i si i+2^k-1
            Folosesc ideea de cautare binara: minimul pe intervalul mare este minimul dintre minimele din
        cele doua jumatati:
            RMQ[ k ][ i ] = min( RMQ[ k-1 ][ i ], RMQ[ k-1 ][ i+2^(k-1) ])
            Astfel pot sa precalculez toate aceste intervale in O(NlogN), iar apoi voi putea raspunde pentru
        un interval oarecare in O(1).

    * Stramosi - smen de smen
            Smenul de la problema clasica stramosi face in esenta ce face si RMQ: precalculeaza stramosul de ordin
        2^k al unui nod i, apoi daca vreau sa aflu stramosul de ordin p al unui nod x, ma folosesc de reprezentarea
        binara a lui p. Asemanator se poate tine o dinamica care sa memoreze costul maxim al unei muchii de pe lantul
        de la i la stramosul de ordin 2^k, care ma poate ajuta sa gasesc eficient muchia de cost maxim de la i la un
        anumit stramos (in problema la lca(i,j)). Gasesc un stramos/o muchie de cost maxim in O(logN), deoarece lungimea
        lantului este maxim N, iar numarul de biti necesari reprezentarii lui N este logN.
            Dinamicile rezultate sunt:
            s[ k ][ i ] = strmosul de ordin 2^k a lui i
            maxEdge[ k ][ i ] = costul maxim al unei muchii de pe lantul de la i la
                            stramosul de ordin 2^k al lui i

            Recurente:
                ** Stramosul de ordin 2^k a lui i, este stramosul de ordin 2^(k-1) al stramosului de ordin 2^(k-1) al lui i
                    s[ k ][ i ] = s[ k - 1 ][ s[ k - 1 ][ i ] ];
                ** Costul maxim al unei muchii de pe lantul, este maximul dintre cele doua costuri
                    maxEdge[ k ][ i ] = std::max(maxEdge[ k - 1 ][ i ], maxEdge[ k - 1 ][ s[ k - 1 ][ i ] ]);

    Complexitate finala:
    O(MlogM + Mlog*N + N + NlogN + QlogN) = O(MlogM + QlogN)

	Problema 2 - Portal
	Problema ne cere sa aflam numarul de noduri izolate. O sa fac cateva obsevatii.
Voi considera ca graful este CONEX (daca nu este conex, rationamentul urmator se
aplica pentru fiecare componenta conexa in parte).
	1. Daca graful este un arbore cu N noduri, atunci el are N-1 muchii. Prin urmare
N-1 muchii vor "intra" (in sensul orientarii arcelor finale) in noduri, adica doar
N-1 noduri vor putea fi accesate. Prin urmare, in acest caz o sa obtin un singur
nod izolat. Demonstratia este triviala: se va face o parcurgere in adancime dintr-un
nod oarecare, arcele vor fi orientate de la parinte catre fiu. Toate nodurile care
vor avea tata nu sunt izolate, radacina este singurul nod izolat.
    2. Daca as vrea ca in graful de la punctul 1 sa raman cu 0 noduri izolate,
ar trebui sa mai adaug o muchie care sa intre in nodul izolat. Celalalt capat al
muchiei nu poate fi un nod nou, deoarece acesta va fi la randul sau izolat.
Prin urmare celalalt capat al muchiei este tot un nod din graf. Am obtinut astfel
un ciclu. Demonstratia existentei solutiei: daca graful are cel putin un ciclu,
aleg ca toate arcele din acelasi ciclu au aceeasi orientare, astfel obtin ca
toate nodurile care apartin unui ciclu nu sunt izolate deoarece in ele intra
cel putin o muchie (care face parte din acel ciclu). Consider aceste noduri
din cicluri vizitate, si vizitez nodurile care se leaga imediat de un ciclu
oarecare, dar care nu fac parte din nici un ciclu, pe care le bag intr-o coada.
Sensul arcului va fi dinspre nodul din ciclu (care deja nu mai e nod izolat)
inspre nodul dinafara ciclului. Cat timp goada nu este goala se scoate
un nod din coada si se viziteaza un vecin nevizitat, sensul arcului va fi
catre vecinul nou descoperit. In acest fel obtin sigur ca nodurile care
nu fac parte din nici un ciclu nu sunt izolate pentru ca parcurgerea BFS
se face dinspre ciclu spre ele.

	Din 1 si 2 trag concluzia ca daca graful este arbore o sa am un nod izolat.
altfel nu o sa am noduri izolate.  Conditia anterioara se rezuma la a gasi
daca graful contine sau nu cicluri (reamintesc ca am considerat ca am un graf conex).
	Pentru a gasi un ciclu in graf, folosesc doar o parcurgere in adancime.
Daca la un moment dat vizitez un nod care este frunza in arborele de parcurgere
DFS (din care nu mai pot merge in nici un alt nod) iar acesta are cel putin
un vecin diferit de tatal lui, inseamna ca muchia de la acest nod la vecinul
diferit de tata este o muchie de intoarcere. Prin urmare aceasta muchie
inchide un ciclu.
	Daca gasesc cel putin o muchie de intoarcere, atunci graful contine
cel putin un ciclu, altfel inseamna ca este un arbore.

	Pentru a obtine raspunsul pentru graful dat, aplic algoritmul de mai sus pentru
fiecare componenta conexa.
	Complexitatea temporala finala este O(N + M), intrucat vizitez toate nodurile si
parcurgand toate muchiile in cautarea unei muchii de intoarcere.
	Memoria folosita este O(N + M), intrucat retin muchiile si vectoroul de tati
(folosesc acest vectorul si pentru a marca ca un nod este vizitat).

	P.S. Am folosit C++11 si am compilat cu -O3.
(Doar ca sa va oftic. Am complexitate optima oricum, deci nu ma puteti depuncta. Voiam sa vad si daca cititi asta. :p)
